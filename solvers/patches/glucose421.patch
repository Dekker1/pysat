diff -Naur build/solvers/glucose421/core/BoundedQueue.h solvers/glucose421/core/BoundedQueue.h
--- build/solvers/glucose421/core/BoundedQueue.h	2023-05-09 15:19:52.000000000 +0200
+++ solvers/glucose421/core/BoundedQueue.h	2023-07-04 16:12:37.708327670 +0200
@@ -48,14 +48,14 @@
  **************************************************************************************************/
 
 
-#ifndef BoundedQueue_h
-#define BoundedQueue_h
+#ifndef Glucose421_BoundedQueue_h
+#define Glucose421_BoundedQueue_h
 
-#include "mtl/Vec.h"
+#include "glucose421/mtl/Vec.h"
 
 //=================================================================================================
 
-namespace Glucose {
+namespace Glucose421 {
 
 template <class T>
 class bqueue {
diff -Naur build/solvers/glucose421/core/lcm.cc solvers/glucose421/core/lcm.cc
--- build/solvers/glucose421/core/lcm.cc	2023-05-09 15:19:52.000000000 +0200
+++ solvers/glucose421/core/lcm.cc	2023-07-04 16:12:37.708327670 +0200
@@ -1,6 +1,7 @@
-#include "Solver.h"
-#include "mtl/Sort.h"
-using namespace Glucose;
+#include "glucose421/core/Solver.h"
+#include "glucose421/mtl/Sort.h"
+
+using namespace Glucose421;
 
 
 
@@ -25,18 +26,18 @@
 
             Lit imp = wbin[k].blocker;
 
-            if (value(imp) == l_False){
+            if (value(imp) == g421l_False){
                 return wbin[k].cref;
             }
 
-            if (value(imp) == l_Undef){
+            if (value(imp) == g421l_Undef){
                 simpleUncheckEnqueue(imp, wbin[k].cref);
             }
         }
         for (i = j = (Watcher*)ws, end = i + ws.size(); i != end;){
             // Try to avoid inspecting the clause:
             Lit blocker = i->blocker;
-            if (value(blocker) == l_True){
+            if (value(blocker) == g421l_True){
                 *j++ = *i++; continue;
             }
 
@@ -54,7 +55,7 @@
             // why not simply do i->blocker=first in this case?
             Lit     first = c[0];
             //  Watcher w     = Watcher(cr, first);
-            if (first != blocker && value(first) == l_True){
+            if (first != blocker && value(first) == g421l_True){
                 i->blocker = first;
                 *j++ = *i++; continue;
             }
@@ -63,7 +64,7 @@
             if (incremental){ // ----------------- INCREMENTAL MODE
                 int choosenPos = -1;
                 for (int k = 2; k < c.size(); k++){
-                    if (value(c[k]) != l_False){
+                    if (value(c[k]) != g421l_False){
                         if (decisionLevel()>assumptions.size()){
                             choosenPos = k;
                             break;
@@ -71,7 +72,7 @@
                         else{
                             choosenPos = k;
 
-                            if (value(c[k]) == l_True || !isSelector(var(c[k]))) {
+                            if (value(c[k]) == g421l_True || !isSelector(var(c[k]))) {
                                 break;
                             }
                         }
@@ -91,7 +92,7 @@
             else{  // ----------------- DEFAULT  MODE (NOT INCREMENTAL)
                 for (int k = 2; k < c.size(); k++){
 
-                    if (value(c[k]) != l_False){
+                    if (value(c[k]) != g421l_False){
                         // watcher i is abandonned using i++, because cr watches now ~c[k] instead of p
                         // the blocker is first in the watcher. However,
                         // the blocker in the corresponding watcher in ~first is not c[1]
@@ -106,7 +107,7 @@
             // Did not find watch -- clause is unit under assignment:
             i->blocker = first;
             *j++ = *i++;
-            if (value(first) == l_False){
+            if (value(first) == g421l_False){
                 confl = cr;
                 qhead = trail.size();
                 // Copy the remaining watches:
@@ -138,7 +139,7 @@
     for(i = j = (Watcher *) ws, end = i + ws.size(); i != end;) {
         // Try to avoid inspecting the clause:
         Lit blocker = i->blocker;
-        if(value(blocker) == l_True) {
+        if(value(blocker) == g421l_True) {
             *j++ = *i++;
             continue;
         }
@@ -155,7 +156,7 @@
         i++;
         Watcher w = Watcher(cr, c[0]);
         for(int k = 1; k < c.size(); k++) {
-            if(value(c[k]) != l_False) {
+            if(value(c[k]) != g421l_False) {
                 c[0] = c[k];
                 c[k] = false_lit;
                 unaryWatches[~c[0]].push(w);
@@ -181,7 +182,7 @@
 
 
 void Solver::simpleUncheckEnqueue(Lit p, CRef from){
-    assert(value(p) == l_Undef);
+    assert(value(p) == g421l_Undef);
     assigns[var(p)] = lbool(!sign(p)); // this makes a lbool object whose value is sign(p)
     vardata[var(p)].reason = from;
     trail.push_(p);
@@ -192,7 +193,7 @@
     for (int c = trail.size() - 1; c >= trailRecord; c--)
     {
         Var x = var(trail[c]);
-        assigns[x] = l_Undef;
+        assigns[x] = g421l_Undef;
 
     }
     qhead = trailRecord;
@@ -224,9 +225,9 @@
             Clause& c = ca[confl];
             // Special case for binary clauses
             // The first one has to be SAT
-            if (p != lit_Undef && c.size() == 2 && value(c[0]) == l_False) {
+            if (p != lit_Undef && c.size() == 2 && value(c[0]) == g421l_False) {
 
-                assert(value(c[1]) == l_True);
+                assert(value(c[1]) == g421l_True);
                 Lit tmp = c[0];
                 c[0] = c[1], c[1] = tmp;
             }
@@ -274,8 +275,8 @@
     CRef confl;
 
     for (i = 0, j = 0; i < c.size(); i++){
-        if (value(c[i]) == l_Undef){
-            //printf("///@@@ uncheckedEnqueue:index = %d. l_Undef\n", i);
+        if (value(c[i]) == g421l_Undef){
+            //printf("///@@@ uncheckedEnqueue:index = %d. g421l_Undef\n", i);
             simpleUncheckEnqueue(~c[i]);
             c[j++] = c[i];
             confl = simplePropagate();
@@ -284,8 +285,8 @@
             }
         }
         else{
-            if (value(c[i]) == l_True){
-                //printf("///@@@ uncheckedEnqueue:index = %d. l_True\n", i);
+            if (value(c[i]) == g421l_True){
+                //printf("///@@@ uncheckedEnqueue:index = %d. g421l_True\n", i);
                 c[j++] = c[i];
                 True_confl = true;
                 confl = reason(var(c[i]));
@@ -293,7 +294,7 @@
             }
             else{
                 falseLit.push(c[i]);
-                //printf("///@@@ uncheckedEnqueue:index = %d. l_False\n", i);
+                //printf("///@@@ uncheckedEnqueue:index = %d. g421l_False\n", i);
             }
         }
     }
@@ -350,11 +351,11 @@
             if (!removed(cr)){
                 sat = false_lit = false;
                 for (int i = 0; i < c.size(); i++){
-                    if (value(c[i]) == l_True){
+                    if (value(c[i]) == g421l_True){
                         sat = true;
                         break;
                     }
-                    else if (value(c[i]) == l_False){
+                    else if (value(c[i]) == g421l_False){
                         false_lit = true;
                     }
                 }
@@ -366,7 +367,7 @@
 
                     if (false_lit){
                         for (li = lj = 0; li < c.size(); li++){
-                            if (value(c[li]) != l_False){
+                            if (value(c[li]) != g421l_False){
                                 c[lj++] = c[li];
                             }
                         }
@@ -444,11 +445,11 @@
             if (!removed(cr)){
                 sat = false_lit = false;
                 for (int i = 0; i < c.size(); i++){
-                    if (value(c[i]) == l_True){
+                    if (value(c[i]) == g421l_True){
                         sat = true;
                         break;
                     }
-                    else if (value(c[i]) == l_False){
+                    else if (value(c[i]) == g421l_False){
                         false_lit = true;
                     }
                 }
@@ -460,7 +461,7 @@
 
                     if (false_lit){
                         for (li = lj = 0; li < c.size(); li++){
-                            if (value(c[li]) != l_False){
+                            if (value(c[li]) != g421l_False){
                                 c[lj++] = c[li];
                             }
                         }
diff -Naur build/solvers/glucose421/core/Solver.cc solvers/glucose421/core/Solver.cc
--- build/solvers/glucose421/core/Solver.cc	2023-05-09 15:19:52.000000000 +0200
+++ solvers/glucose421/core/Solver.cc	2023-07-04 16:25:01.196127093 +0200
@@ -49,13 +49,12 @@
 
 #include <math.h>
 
-#include "utils/System.h"
-#include "mtl/Sort.h"
-#include "core/Solver.h"
-#include "core/Constants.h"
-#include"simp/SimpSolver.h"
+#include "glucose421/utils/System.h"
+#include "glucose421/mtl/Sort.h"
+#include "glucose421/core/Solver.h"
+#include "glucose421/core/Constants.h"
 
-using namespace Glucose;
+using namespace Glucose421;
 
 
 //=================================================================================================
@@ -183,6 +182,7 @@
 , order_heap(VarOrderLt(activity))
 , progress_estimate(0)
 , remove_satisfied(true)
+, warm_start(false)
 ,lastLearntClause(CRef_Undef)
 // Resource constraints:
 //
@@ -389,7 +389,7 @@
     watchesBin.init(mkLit(v, true));
     unaryWatches.init(mkLit(v, false));
     unaryWatches.init(mkLit(v, true));
-    assigns.push(l_Undef);
+    assigns.push(g421l_Undef);
     vardata.push(mkVarData(CRef_Undef, 0));
     activity.push(rnd_init_act ? drand(random_seed) * 0.00001 : 0);
     seen.push(0);
@@ -421,15 +421,15 @@
     if(certifiedUNSAT) {
         for(i = j = 0, p = lit_Undef; i < ps.size(); i++) {
             oc.push(ps[i]);
-            if(value(ps[i]) == l_True || ps[i] == ~p || value(ps[i]) == l_False)
+            if(value(ps[i]) == g421l_True || ps[i] == ~p || value(ps[i]) == g421l_False)
                 flag = 1;
         }
     }
 
     for(i = j = 0, p = lit_Undef; i < ps.size(); i++)
-        if(value(ps[i]) == l_True || ps[i] == ~p)
+        if(value(ps[i]) == g421l_True || ps[i] == ~p)
             return true;
-        else if(value(ps[i]) != l_False && ps[i] != p)
+        else if(value(ps[i]) != g421l_False && ps[i] != p)
             ps[j++] = p = ps[i];
     ps.shrink(i - j);
 
@@ -543,12 +543,12 @@
 bool Solver::satisfied(const Clause &c) const {
 #ifdef INCREMENTAL
     if(incremental)
-        return (value(c[0]) == l_True) || (value(c[1]) == l_True);
+        return (value(c[0]) == g421l_True) || (value(c[1]) == g421l_True);
 #endif
 
     // Default mode
     for(int i = 0; i < c.size(); i++)
-        if(value(c[i]) == l_True)
+        if(value(c[i]) == g421l_True)
             return true;
     return false;
 }
@@ -575,7 +575,7 @@
         int nb = 0;
         for(int k = 0; k < wbin.size(); k++) {
             Lit imp = wbin[k].blocker;
-            if(permDiff[var(imp)] == MYFLAG && value(imp) == l_True) {
+            if(permDiff[var(imp)] == MYFLAG && value(imp) == g421l_True) {
                 nb++;
                 permDiff[var(imp)] = MYFLAG - 1;
             }
@@ -606,7 +606,7 @@
     if(decisionLevel() > level) {
         for(int c = trail.size() - 1; c >= trail_lim[level]; c--) {
             Var x = var(trail[c]);
-            assigns[x] = l_Undef;
+            assigns[x] = g421l_Undef;
             if(phase_saving > 1 || ((phase_saving == 1) && c > trail_lim.last())) {
                 polarity[x] = sign(trail[c]);
             }
@@ -628,12 +628,12 @@
     // Random decision:
     if(((randomizeFirstDescent && conflicts == 0) || drand(random_seed) < random_var_freq) && !order_heap.empty()) {
         next = order_heap[irand(random_seed, order_heap.size())];
-        if(value(next) == l_Undef && decision[next])
+        if(value(next) == g421l_Undef && decision[next])
             stats[rnd_decisions]++;
     }
 
     // Activity based decision:
-    while(next == var_Undef || value(next) != l_Undef || !decision[next])
+    while(next == var_Undef || value(next) != g421l_Undef || !decision[next])
         if(order_heap.empty()) {
             next = var_Undef;
             break;
@@ -693,9 +693,9 @@
         Clause &c = ca[confl];
         // Special case for binary clauses
         // The first one has to be SAT
-        if(p != lit_Undef && c.size() == 2 && value(c[0]) == l_False) {
+        if(p != lit_Undef && c.size() == 2 && value(c[0]) == g421l_False) {
 
-            assert(value(c[1]) == l_True);
+            assert(value(c[1]) == g421l_True);
             Lit tmp = c[0];
             c[0] = c[1], c[1] = tmp;
         }
@@ -752,7 +752,7 @@
                             lastDecisionLevel.push(q);
                     } else {
                         if(isSelector(var(q))) {
-                            assert(value(q) == l_False);
+                            assert(value(q) == g421l_False);
                             selectors.push(q);
                         } else
                             out_learnt.push(q);
@@ -878,8 +878,8 @@
         assert(reason(var(analyze_stack.last())) != CRef_Undef);
         Clause &c = ca[reason(var(analyze_stack.last()))];
         analyze_stack.pop(); //
-        if(c.size() == 2 && value(c[0]) == l_False) {
-            assert(value(c[1]) == l_True);
+        if(c.size() == 2 && value(c[0]) == g421l_False) {
+            assert(value(c[1]) == g421l_True);
             Lit tmp = c[0];
             c[0] = c[1], c[1] = tmp;
         }
@@ -950,7 +950,7 @@
 
 
 void Solver::uncheckedEnqueue(Lit p, CRef from) {
-    assert(value(p) == l_Undef);
+    assert(value(p) == g421l_Undef);
     assigns[var(p)] = lbool(!sign(p));
     vardata[var(p)] = mkVarData(from, decisionLevel());
     trail.push_(p);
@@ -962,6 +962,58 @@
     return;
 }
 
+//=================================================================================================
+// Propagate and check (added for PySat):
+bool Solver::prop_check(const vec<Lit>& assumps, vec<Lit>& prop, int psaving)
+{
+    prop.clear();
+
+    if (!ok)
+        return false;
+
+    bool    st = true;
+    int  level = decisionLevel();
+    CRef confl = CRef_Undef;
+
+    // dealing with phase saving
+    int psaving_copy = phase_saving;
+    phase_saving = psaving;
+
+    // propagate each assumption at a new decision level
+    for (int i = 0; st && confl == CRef_Undef && i < assumps.size(); ++i) {
+        Lit p = assumps[i];
+
+        if (value(p) == g421l_False)
+            st = false;
+        else if (value(p) != g421l_True) {
+            newDecisionLevel ();
+            uncheckedEnqueue(p);
+            confl = propagate();
+        }
+    }
+
+    // copying the result
+    if (decisionLevel() > level) {
+        for (int c = trail_lim[level]; c < trail.size(); ++c)
+            prop.push(trail[c]);
+
+        // if there is a conflict, pushing
+        // the conflicting literal as well
+        // here we may choose a wrong literal
+        // in Glucose if the clause is binary!
+        if (confl != CRef_Undef)
+            prop.push(ca[confl][0]);
+
+        // backtracking
+        cancelUntil(level);
+    }
+
+    // restoring phase saving
+    phase_saving = psaving_copy;
+
+    return st && confl == CRef_Undef;
+}
+
 
 /*_________________________________________________________________________________________________
 |
@@ -993,11 +1045,11 @@
 
             Lit imp = wbin[k].blocker;
 
-            if(value(imp) == l_False) {
+            if(value(imp) == g421l_False) {
                 return wbin[k].cref;
             }
 
-            if(value(imp) == l_Undef) {
+            if(value(imp) == g421l_Undef) {
                 uncheckedEnqueue(imp, wbin[k].cref);
             }
         }
@@ -1006,7 +1058,7 @@
         for(i = j = (Watcher *) ws, end = i + ws.size(); i != end;) {
             // Try to avoid inspecting the clause:
             Lit blocker = i->blocker;
-            if(value(blocker) == l_True) {
+            if(value(blocker) == g421l_True) {
                 *j++ = *i++;
                 continue;
             }
@@ -1024,7 +1076,7 @@
             // If 0th watch is true, then clause is already satisfied.
             Lit first = c[0];
             Watcher w = Watcher(cr, first);
-            if(first != blocker && value(first) == l_True) {
+            if(first != blocker && value(first) == g421l_True) {
 
                 *j++ = w;
                 continue;
@@ -1034,7 +1086,7 @@
               int choosenPos = -1;
               for (int k = 2; k < c.size(); k++) {
 
-            if (value(c[k]) != l_False){
+            if (value(c[k]) != g421l_False){
               if(decisionLevel()>assumptions.size()) {
                 choosenPos = k;
                 break;
@@ -1056,7 +1108,7 @@
 #endif
             for(int k = 2; k < c.size(); k++) {
 
-                if(value(c[k]) != l_False) {
+                if(value(c[k]) != g421l_False) {
                     c[1] = c[k];
                     c[k] = false_lit;
                     watches[~c[1]].push(w);
@@ -1068,7 +1120,7 @@
 #endif
             // Did not find watch -- clause is unit under assignment:
             *j++ = w;
-            if(value(first) == l_False) {
+            if(value(first) == g421l_False) {
                 confl = cr;
                 qhead = trail.size();
                 // Copy the remaining watches:
@@ -1116,7 +1168,7 @@
     for(i = j = (Watcher *) ws, end = i + ws.size(); i != end;) {
         // Try to avoid inspecting the clause:
         Lit blocker = i->blocker;
-        if(value(blocker) == l_True) {
+        if(value(blocker) == g421l_True) {
             *j++ = *i++;
             continue;
         }
@@ -1133,7 +1185,7 @@
         i++;
         Watcher w = Watcher(cr, c[0]);
         for(int k = 1; k < c.size(); k++) {
-            if(value(c[k]) != l_False) {
+            if(value(c[k]) != g421l_False) {
                 c[0] = c[k];
                 c[k] = false_lit;
                 unaryWatches[~c[0]].push(w);
@@ -1158,7 +1210,7 @@
             int maxlevel = -1;
             int index = -1;
             for(int k = 1; k < c.size(); k++) {
-                assert(value(c[k]) == l_False);
+                assert(value(c[k]) == g421l_False);
                 assert(level(var(c[k])) <= level(var(c[0])));
                 if(level(var(c[k])) > maxlevel) {
                     index = k;
@@ -1267,7 +1319,7 @@
 void Solver::rebuildOrderHeap() {
     vec <Var> vs;
     for(Var v = 0; v < nVars(); v++)
-        if(decision[v] && value(v) == l_Undef)
+        if(decision[v] && value(v) == g421l_Undef)
             vs.push(v);
     order_heap.build(vs);
 
@@ -1442,7 +1494,7 @@
         //printf("nbClauses : %d, nbLearnts : %d\n", clauses.size(), learnts.size());
         if (!simplifyAll())
         {
-            return l_False;
+            return g421l_False;
         }
         performLCM = 0;
     }
@@ -1453,7 +1505,7 @@
             parallelImportUnaryClauses();
 
             if(parallelImportClauses())
-                return l_False;
+                return g421l_False;
 
         }
         CRef confl = propagate();
@@ -1461,7 +1513,7 @@
         if(confl != CRef_Undef) {
             newDescent = false;
             if(parallelJobIsFinished())
-                return l_Undef;
+                return g421l_Undef;
 
             if(!aDecisionWasMade)
                 stats[noDecisionConflict]++;
@@ -1483,14 +1535,14 @@
                        (int) stats[nbReduceDB], nLearnts(), (int) stats[nbDL2], (int) stats[nbRemovedClauses], progressEstimate() * 100);
             }
             if(decisionLevel() == 0) {
-                return l_False;
+                return g421l_False;
 
             }
             if(adaptStrategies && conflicts == 100000) {
                 cancelUntil(0);
                 adaptSolver();
                 adaptStrategies = false;
-                return l_Undef;
+                return g421l_Undef;
             }
 
             trailQueue.push(trail.size());
@@ -1573,13 +1625,13 @@
                 }
 
                 cancelUntil(bt);
-                return l_Undef;
+                return g421l_Undef;
             }
 
 
             // Simplify the set of problem clauses:
             if(decisionLevel() == 0 && !simplify()) {
-                return l_False;
+                return g421l_False;
             }
             // Perform clause database reduction !
             if((chanseokStrategy && !glureduce && learnts.size() > firstReduceDB) ||
@@ -1599,12 +1651,12 @@
             while(decisionLevel() < assumptions.size()) {
                 // Perform user provided assumption:
                 Lit p = assumptions[decisionLevel()];
-                if(value(p) == l_True) {
+                if(value(p) == g421l_True) {
                     // Dummy decision level:
                     newDecisionLevel();
-                } else if(value(p) == l_False) {
+                } else if(value(p) == g421l_False) {
                     analyzeFinal(~p, conflict);
-                    return l_False;
+                    return g421l_False;
                 } else {
                     next = p;
                     break;
@@ -1618,7 +1670,7 @@
                 if(next == lit_Undef) {
                     printf("c last restart ## conflicts  :  %d %d \n", conflictC, decisionLevel());
                     // Model found:
-                    return l_True;
+                    return g421l_True;
                 }
             }
 
@@ -1713,13 +1765,13 @@
 
     model.clear();
     conflict.clear();
-    if(!ok) return l_False;
+    if(!ok) return g421l_False;
     double curTime = cpuTime();
 
     solves++;
 
 
-    lbool status = l_Undef;
+    lbool status = g421l_Undef;
     if(!incremental && verbosity >= 1) {
         printf("c ========================================[ MAGIC CONSTANTS ]==============================================\n");
         printf("c | Constants are supposed to work well together :-)                                                      |\n");
@@ -1757,7 +1809,7 @@
 
     // Search:
     int curr_restarts = 0;
-    while(status == l_Undef) {
+    while(status == g421l_Undef) {
         status = search(
                 luby_restart ? luby(restart_inc, curr_restarts) * luby_restart_factor : 0); // the parameter is useless in glucose, kept to allow modifications
 
@@ -1769,7 +1821,7 @@
         printf("c =========================================================================================================\n");
 
     if(certifiedUNSAT) { // Want certified output
-        if(status == l_False) {
+        if(status == g421l_False) {
             if(vbyte) {
                 write_char('a');
                 write_lit(0);
@@ -1782,23 +1834,23 @@
     }
 
 
-    if(status == l_True) {
+    if(status == g421l_True) {
         // Extend & copy model:
         model.growTo(nVars());
         for(int i = 0; i < nVars(); i++) model[i] = value(i);
-    } else if(status == l_False && conflict.size() == 0)
+    } else if(status == g421l_False && conflict.size() == 0)
         ok = false;
 
-
-    cancelUntil(0);
-
+    //cancelUntil(0);
+    if (!warm_start || status != g421l_True)  // no 'default' backtracking in case of warm restarts
+        cancelUntil(0);
 
     double finalTime = cpuTime();
-    if(status == l_True) {
+    if(status == g421l_True) {
         nbSatCalls++;
         totalTime4Sat += (finalTime - curTime);
     }
-    if(status == l_False) {
+    if(status == g421l_False) {
         nbUnsatCalls++;
         totalTime4Unsat += (finalTime - curTime);
     }
@@ -1808,7 +1860,194 @@
 
 }
 
+//=================================================================================================
+// Add a clause in the warm start mode:
+bool Solver::addClauseWarm(vec<Lit>& ps)
+{
+    if (!ok) return false;
+    if (!warm_start || decisionLevel() == 0) return addClause(ps);
 
+    // checking if clause is satisfied and remove false/duplicate literals
+    sort(ps);
+    Lit p; int i, j, nws, max_i;
+    vec<int> ws(2, -1);  // potentially watched literals
+    for (i = j = nws = max_i = 0, p = lit_Undef; i < ps.size(); i++) {
+        Var x = var(ps[i]);
+        if ((value(ps[i]) == g421l_True && level(x) == 0) || ps[i] == ~p)
+            return true;
+        else if ((value(ps[i]) != g421l_False || level(x) > 0) && ps[i] != p) {
+            if (value(ps[i]) != g421l_False && nws < 2)
+                ws[nws++] = j;
+            if (level(x) > level(var(ps[max_i])))
+                max_i = j;
+
+            ps[j++] = p = ps[i];
+        }
+    }
+    ps.shrink(i - j);
+
+    // analyzing which level to backtrack to (if any)
+    if (ps.size() != 0) {
+        if (ps.size() > 1) {
+            if (nws) {
+                p = ps[0]; ps[0] = ps[ws[0]]; ps[ws[0]] = p;
+                if (nws == 2) {
+                    p = ps[1]; ps[1] = ps[ws[1]]; ps[ws[1]] = p;
+                }
+            }
+            else {
+                // no satisfied literals in this clause
+                p = ps[max_i]; ps[max_i] = ps[0]; ps[0] = p;
+
+                max_i = 1;
+                for (int i = 2; i < ps.size(); ++i) {
+                    if (level(var(ps[i])) > level(var(ps[max_i])))
+                        max_i = i;
+                }
+
+                p = ps[max_i]; ps[max_i] = ps[1]; ps[1] = p;
+
+                cancelUntil(level(var(p)));
+            }
+            CRef cr = ca.alloc(ps, false);
+            clauses.push(cr);
+            attachClause(cr);
+
+            if (!nws) {
+                // if the clause was falsified
+                if (value(ps[0]) == g421l_Undef)
+                    // enqueue unless already true
+                    uncheckedEnqueue(ps[0], cr);
+                else if (value(ps[0]) == g421l_False && resolveConflicts(cr) == false)
+                    ok = false;
+            }
+        }
+        else {
+            // a single literal in the clause => enqueue it at level 0
+            cancelUntil(0);
+            uncheckedEnqueue(ps[0]);
+            ok = (propagate() == CRef_Undef);
+        }
+    }
+    else {
+        // there is no literal left in the clause!
+        cancelUntil(0);
+        ok = false;
+    }
+
+    return ok;
+}
+
+//=================================================================================================
+// Resolve conflicts, if appear after adding a clause in the warm start mode:
+bool Solver::resolveConflicts(CRef confl)
+{
+    int backtrack_level;
+    vec <Lit> learnt_clause, selectors;
+    unsigned int nblevels, szWithoutSelectors = 0;
+    bool blocked = false;
+    bool aDecisionWasMade = false;
+
+    while (confl != CRef_Undef) {
+        newDescent = false;
+        /* if(parallelJobIsFinished()) */
+        /*     return g421l_Undef; */
+
+        if(!aDecisionWasMade)
+            stats[noDecisionConflict]++;
+        aDecisionWasMade = false;
+
+        stats[sumDecisionLevels] += decisionLevel();
+        stats[sumTrail] += trail.size();
+        // CONFLICT
+        conflicts++;
+        conflictsRestarts++;
+        if(conflicts % 5000 == 0 && var_decay < max_var_decay)
+            var_decay += 0.01;
+
+        if(decisionLevel() == 0) return false;
+
+        /* if(adaptStrategies && conflicts == 100000) { */
+        /*     cancelUntil(0); */
+        /*     adaptSolver(); */
+        /*     adaptStrategies = false; */
+        /*     return g421l_Undef; */
+        /* } */
+
+        trailQueue.push(trail.size());
+        // BLOCK RESTART (CP 2012 paper)
+        if(conflictsRestarts > LOWER_BOUND_FOR_BLOCKING_RESTART && lbdQueue.isvalid() && trail.size() > R * trailQueue.getavg()) {
+            lbdQueue.fastclear();
+            stats[nbstopsrestarts]++;
+            if(!blocked) {
+                stats[lastblockatrestart] = starts;
+                stats[nbstopsrestartssame]++;
+                blocked = true;
+            }
+        }
+
+        learnt_clause.clear();
+        selectors.clear();
+
+        analyze(confl, learnt_clause, selectors, backtrack_level, nblevels, szWithoutSelectors);
+
+        lbdQueue.push(nblevels);
+        sumLBD += nblevels;
+
+        cancelUntil(backtrack_level);
+
+        if(certifiedUNSAT) {
+            if(vbyte) {
+                write_char('a');
+                for(int i = 0; i < learnt_clause.size(); i++)
+                    write_lit(2 * (var(learnt_clause[i]) + 1) + sign(learnt_clause[i]));
+                write_lit(0);
+            }
+            else {
+                for(int i = 0; i < learnt_clause.size(); i++)
+                    fprintf(certifiedOutput, "%i ", var(learnt_clause[i]) *
+                                                    (-2 * sign(learnt_clause[i]) + 1));
+                fprintf(certifiedOutput, "0\n");
+            }
+        }
+
+
+        if(learnt_clause.size() == 1) {
+            uncheckedEnqueue(learnt_clause[0]);
+            stats[nbUn]++;
+            parallelExportUnaryClause(learnt_clause[0]);
+        } else {
+            CRef cr;
+            if(chanseokStrategy && nblevels <= coLBDBound) {
+                cr = ca.alloc(learnt_clause, false);
+                permanentLearnts.push(cr);
+                stats[nbPermanentLearnts]++;
+            } else {
+                cr = ca.alloc(learnt_clause, true);
+                ca[cr].setLBD(nblevels);
+                ca[cr].setOneWatched(false);
+                learnts.push(cr);
+                claBumpActivity(ca[cr]);
+            }
+#ifdef INCREMENTAL
+            ca[cr].setSizeWithoutSelectors(szWithoutSelectors);
+#endif
+            if(nblevels <= 2) { stats[nbDL2]++; } // stats
+            if(ca[cr].size() == 2) stats[nbBin]++; // stats
+            attachClause(cr);
+            lastLearntClause = cr; // Use in multithread (to hard to put inside ParallelSolver)
+            parallelExportClauseDuringSearch(ca[cr]);
+            uncheckedEnqueue(learnt_clause[0], cr);
+        }
+
+        varDecayActivity();
+        claDecayActivity();
+
+        confl = propagate();
+    }
+
+    return true;
+}
 
 
 
@@ -1830,7 +2069,7 @@
     if(satisfied(c)) return;
 
     for(int i = 0; i < c.size(); i++)
-        if(value(c[i]) != l_False)
+        if(value(c[i]) != g421l_False)
             fprintf(f, "%s%d ", sign(c[i]) ? "-" : "", mapVar(var(c[i]), map, max) + 1);
     fprintf(f, "0\n");
 }
@@ -1866,7 +2105,7 @@
         if(!satisfied(ca[clauses[i]])) {
             Clause &c = ca[clauses[i]];
             for(int j = 0; j < c.size(); j++)
-                if(value(c[j]) != l_False)
+                if(value(c[j]) != g421l_False)
                     mapVar(var(c[j]), map, max);
         }
 
@@ -1876,7 +2115,7 @@
     fprintf(f, "p cnf %d %d\n", max, cnt);
 
     for(int i = 0; i < assumptions.size(); i++) {
-        assert(value(assumptions[i]) != l_False);
+        assert(value(assumptions[i]) != g421l_False);
         fprintf(f, "%s%d 0\n", sign(assumptions[i]) ? "-" : "", mapVar(var(assumptions[i]), map, max) + 1);
     }
 
diff -Naur build/solvers/glucose421/core/Solver.h solvers/glucose421/core/Solver.h
--- build/solvers/glucose421/core/Solver.h	2023-05-09 15:19:52.000000000 +0200
+++ solvers/glucose421/core/Solver.h	2023-07-04 16:17:31.345745020 +0200
@@ -47,20 +47,20 @@
 OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  **************************************************************************************************/
 
-#ifndef Glucose_Solver_h
-#define Glucose_Solver_h
+#ifndef Glucose421_Solver_h
+#define Glucose421_Solver_h
 
-#include "mtl/Heap.h"
-#include "mtl/Alg.h"
-#include "utils/Options.h"
-#include "core/SolverTypes.h"
-#include "core/BoundedQueue.h"
-#include "core/Constants.h"
-#include "mtl/Clone.h"
-#include "core/SolverStats.h"
+#include "glucose421/mtl/Heap.h"
+#include "glucose421/mtl/Alg.h"
+#include "glucose421/utils/Options.h"
+#include "glucose421/core/SolverTypes.h"
+#include "glucose421/core/BoundedQueue.h"
+#include "glucose421/core/Constants.h"
+#include "glucose421/mtl/Clone.h"
+#include "glucose421/core/SolverStats.h"
 
 
-namespace Glucose {
+namespace Glucose421 {
 // Core stats 
 
 enum CoreStats {
@@ -137,6 +137,7 @@
     bool    solve        (Lit p, Lit q);            // Search for a model that respects two assumptions.
     bool    solve        (Lit p, Lit q, Lit r);     // Search for a model that respects three assumptions.
     bool    okay         () const;                  // FALSE means solver is in a conflicting state
+    bool    prop_check   (const vec<Lit>& assumps, vec<Lit>& prop, int psaving = 0); // compute a list of propagated literals given a set of assumptions
 
        // Convenience versions of 'toDimacs()':
     void    toDimacs     (FILE* f, const vec<Lit>& assumps);            // Write CNF to file in DIMACS-format.
@@ -169,6 +170,11 @@
     int     nVars      ()      const;       // The current number of variables.
     int     nFreeVars  ()      ;
 
+    // Warm start mode:
+    void setStartMode(bool warm = false);
+    bool addClauseWarm(vec<Lit>& ps);
+    bool resolveConflicts(CRef confl);
+
     inline char valuePhase(Var v) {return polarity[v];}
 
     // Incremental mode
@@ -357,6 +363,7 @@
     Heap<VarOrderLt>    order_heap;       // A priority queue of variables ordered with respect to the variable activity.
     double              progress_estimate;// Set by 'search()'.
     bool                remove_satisfied; // Indicates whether possibly inefficient linear scan for satisfied clauses should be performed in 'simplify'.
+    bool                warm_start;       // Warm start if set to true.
     vec<unsigned int>   permDiff;           // permDiff[var] contains the current conflict number... Used to count the number of  LBD
 
 
@@ -537,7 +544,7 @@
         garbageCollect(); }
 
 // NOTE: enqueue does not set the ok flag! (only public methods do)
-inline bool     Solver::enqueue         (Lit p, CRef from)      { return value(p) != l_Undef ? value(p) != l_False : (uncheckedEnqueue(p, from), true); }
+inline bool     Solver::enqueue         (Lit p, CRef from)      { return value(p) != g421l_Undef ? value(p) != g421l_False : (uncheckedEnqueue(p, from), true); }
 inline bool     Solver::addClause       (const vec<Lit>& ps)    { ps.copyTo(add_tmp); return addClause_(add_tmp); }
 inline bool     Solver::addEmptyClause  ()                      { add_tmp.clear(); return addClause_(add_tmp); }
 inline bool     Solver::addClause       (Lit p)                 { add_tmp.clear(); add_tmp.push(p); return addClause_(add_tmp); }
@@ -545,11 +552,11 @@
 inline bool     Solver::addClause       (Lit p, Lit q, Lit r)   { add_tmp.clear(); add_tmp.push(p); add_tmp.push(q); add_tmp.push(r); return addClause_(add_tmp); }
  inline bool     Solver::locked          (const Clause& c) const {
    if(c.size()>2)
-     return value(c[0]) == l_True && reason(var(c[0])) != CRef_Undef && ca.lea(reason(var(c[0]))) == &c;
+     return value(c[0]) == g421l_True && reason(var(c[0])) != CRef_Undef && ca.lea(reason(var(c[0]))) == &c;
    return
-     (value(c[0]) == l_True && reason(var(c[0])) != CRef_Undef && ca.lea(reason(var(c[0]))) == &c)
+     (value(c[0]) == g421l_True && reason(var(c[0])) != CRef_Undef && ca.lea(reason(var(c[0]))) == &c)
      ||
-     (value(c[1]) == l_True && reason(var(c[1])) != CRef_Undef && ca.lea(reason(var(c[1]))) == &c);
+     (value(c[1]) == g421l_True && reason(var(c[1])) != CRef_Undef && ca.lea(reason(var(c[1]))) == &c);
  }
 inline void     Solver::newDecisionLevel()                      { trail_lim.push(trail.size()); }
 
@@ -588,11 +595,11 @@
 // FIXME: after the introduction of asynchronous interrruptions the solve-versions that return a
 // pure bool do not give a safe interface. Either interrupts must be possible to turn off here, or
 // all calls to solve must return an 'lbool'. I'm not yet sure which I prefer.
-inline bool     Solver::solve         ()                    { budgetOff(); assumptions.clear(); return solve_() == l_True; }
-inline bool     Solver::solve         (Lit p)               { budgetOff(); assumptions.clear(); assumptions.push(p); return solve_() == l_True; }
-inline bool     Solver::solve         (Lit p, Lit q)        { budgetOff(); assumptions.clear(); assumptions.push(p); assumptions.push(q); return solve_() == l_True; }
-inline bool     Solver::solve         (Lit p, Lit q, Lit r) { budgetOff(); assumptions.clear(); assumptions.push(p); assumptions.push(q); assumptions.push(r); return solve_() == l_True; }
-inline bool     Solver::solve         (const vec<Lit>& assumps){ budgetOff(); assumps.copyTo(assumptions); return solve_() == l_True; }
+inline bool     Solver::solve         ()                    { budgetOff(); assumptions.clear(); return solve_() == g421l_True; }
+inline bool     Solver::solve         (Lit p)               { budgetOff(); assumptions.clear(); assumptions.push(p); return solve_() == g421l_True; }
+inline bool     Solver::solve         (Lit p, Lit q)        { budgetOff(); assumptions.clear(); assumptions.push(p); assumptions.push(q); return solve_() == g421l_True; }
+inline bool     Solver::solve         (Lit p, Lit q, Lit r) { budgetOff(); assumptions.clear(); assumptions.push(p); assumptions.push(q); assumptions.push(r); return solve_() == g421l_True; }
+inline bool     Solver::solve         (const vec<Lit>& assumps){ budgetOff(); assumps.copyTo(assumptions); return solve_() == g421l_True; }
 inline lbool    Solver::solveLimited  (const vec<Lit>& assumps){ assumps.copyTo(assumptions); return solve_(); }
 inline bool     Solver::okay          ()      const   { return ok; }
 
@@ -601,6 +608,9 @@
 inline void     Solver::toDimacs     (const char* file, Lit p, Lit q){ vec<Lit> as; as.push(p); as.push(q); toDimacs(file, as); }
 inline void     Solver::toDimacs     (const char* file, Lit p, Lit q, Lit r){ vec<Lit> as; as.push(p); as.push(q); as.push(r); toDimacs(file, as); }
 
+// Warm start mode:
+inline void     Solver::setStartMode (bool warm) { warm_start = warm; cancelUntil(0); }
+
 
 /************************************************************
  * Compute LBD functions
@@ -646,7 +656,7 @@
 
 inline void Solver::printLit(Lit l)
 {
-    printf("%s%d:%c", sign(l) ? "-" : "", var(l)+1, value(l) == l_True ? '1' : (value(l) == l_False ? '0' : 'X'));
+    printf("%s%d:%c", sign(l) ? "-" : "", var(l)+1, value(l) == g421l_True ? '1' : (value(l) == g421l_False ? '0' : 'X'));
 }
 
 
diff -Naur build/solvers/glucose421/core/SolverStats.h solvers/glucose421/core/SolverStats.h
--- build/solvers/glucose421/core/SolverStats.h	2023-05-09 15:19:52.000000000 +0200
+++ solvers/glucose421/core/SolverStats.h	2023-07-04 16:12:37.708327670 +0200
@@ -47,12 +47,12 @@
 OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  **************************************************************************************************/
 
-#ifndef SOLVERSTATS_H
-#define	SOLVERSTATS_H
+#ifndef Glucose421_SOLVERSTATS_H
+#define	Glucose421_SOLVERSTATS_H
 
-#include "mtl/Map.h"
+#include "glucose421/mtl/Map.h"
 #include <string>
-namespace Glucose {
+namespace Glucose421 {
 
     class SolverStats {
     protected:
diff -Naur build/solvers/glucose421/core/SolverTypes.h solvers/glucose421/core/SolverTypes.h
--- build/solvers/glucose421/core/SolverTypes.h	2023-05-09 15:19:52.000000000 +0200
+++ solvers/glucose421/core/SolverTypes.h	2023-07-04 16:12:37.708327670 +0200
@@ -48,21 +48,21 @@
  **************************************************************************************************/
 
 
-#ifndef Glucose_SolverTypes_h
-#define Glucose_SolverTypes_h
+#ifndef Glucose421_SolverTypes_h
+#define Glucose421_SolverTypes_h
 
 #include <assert.h>
 #include <stdint.h>
 #include <pthread.h>
 
-#include "mtl/IntTypes.h"
-#include "mtl/Alg.h"
-#include "mtl/Vec.h"
-#include "mtl/Map.h"
-#include "mtl/Alloc.h"
+#include "glucose421/mtl/IntTypes.h"
+#include "glucose421/mtl/Alg.h"
+#include "glucose421/mtl/Vec.h"
+#include "glucose421/mtl/Map.h"
+#include "glucose421/mtl/Alloc.h"
 
 
-namespace Glucose {
+namespace Glucose421 {
 
 //=================================================================================================
 // Variables, literals, lifted booleans, clauses:
@@ -113,9 +113,9 @@
 //       does enough constant propagation to produce sensible code, and this appears to be somewhat
 //       fragile unfortunately.
 
-#define l_True  (Glucose::lbool((uint8_t)0)) // gcc does not do constant propagation if these are real constants.
-#define l_False (Glucose::lbool((uint8_t)1))
-#define l_Undef (Glucose::lbool((uint8_t)2))
+#define g421l_True  (Glucose421::lbool((uint8_t)0)) // gcc does not do constant propagation if these are real constants.
+#define g421l_False (Glucose421::lbool((uint8_t)1))
+#define g421l_Undef (Glucose421::lbool((uint8_t)2))
 
 class lbool {
     uint8_t value;
diff -Naur build/solvers/glucose421/Makefile solvers/glucose421/Makefile
--- build/solvers/glucose421/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ solvers/glucose421/Makefile	2023-07-04 16:12:37.708327670 +0200
@@ -0,0 +1,42 @@
+### Makefile ---
+
+## Author: aign
+## Keywords:
+
+# main parameters
+#CXX      := c++
+#CXXFLAGS := -std=c++11 -fPIC -Wall -Wno-deprecated -fno-strict-aliasing -DINCREMENTAL
+
+CXX      := g++
+#CXXFLAGS := -Wall -Wno-parentheses -std=c++11 -D __STDC_LIMIT_MACROS -D __STDC_FORMAT_MACROS
+CXXFLAGS := -Wall -Wno-parentheses -std=c++11 -D __STDC_LIMIT_MACROS -D __STDC_FORMAT_MACROS -fPIC -Wl,--no-undefined -lm
+CXXOPT   := -O3 -DNDEBUG
+CXXDEBUG := -O0 -g3
+CXXPROF  := -O3 -g3 -fno-inline -fno-omit-frame-pointer -pg -DNDEBUG
+INCLUDES := -I..
+LIBS     := -L.
+SOURCES  := core/lcm.cc core/Solver.cc utils/Options.cc utils/System.cc
+OBJECTS  := $(SOURCES:.cc=.o)
+TRGT     :=  glucose421
+
+# gather compiler options
+CXXARGS := $(CXXFLAGS) $(INCLUDES) $(CXXOPT)
+
+# targets
+.PHONY: all clean lib
+
+all: lib
+
+lib: $(OBJECTS)
+	@-ar cvq lib$(TRGT).a $(OBJECTS)
+	## @-ar cr lib$(TRGT).a $(OBJECTS)
+
+%.o: %.cc
+	$(CXX) $(CXXARGS) -c $< -o $@
+
+clean:
+	@-rm $(OBJECTS) lib$(TRGT).a
+
+allclean:
+	@-find . -name '*.o' -delete
+	@-find . -name '*.a' -delete
diff -Naur build/solvers/glucose421/Makefile.old solvers/glucose421/Makefile.old
--- build/solvers/glucose421/Makefile.old	1970-01-01 01:00:00.000000000 +0100
+++ solvers/glucose421/Makefile.old	2023-07-04 16:12:37.708327670 +0200
@@ -0,0 +1,37 @@
+### Makefile ---
+
+## Author: aign
+## Keywords:
+
+# main parameters
+CXX      := c++
+CXXFLAGS := -std=c++11 -fPIC -Wall -Wno-deprecated -fno-strict-aliasing -DINCREMENTAL
+CXXOPT   := -O3 -DNDEBUG
+CXXDEBUG := -O0 -g3
+CXXPROF  := -O3 -g3 -fno-inline -fno-omit-frame-pointer -pg -DNDEBUG
+INCLUDES := -I..
+LIBS     := -L.
+SOURCES  := core/Solver.cc core/lmc.cc utils/Options.cc utils/System.cc
+OBJECTS  := $(SOURCES:.cc=.o)
+TRGT     :=  glucose421
+
+# gather compiler options
+CXXARGS := $(CXXFLAGS) $(INCLUDES) $(CXXOPT)
+
+# targets
+.PHONY: all clean lib
+
+all: lib
+
+lib: $(OBJECTS)
+	@-ar cr lib$(TRGT).a $(OBJECTS)
+
+%.o: %.cc
+	$(CXX) $(CXXARGS) -c $< -o $@
+
+clean:
+	@-rm $(OBJECTS)
+
+allclean:
+	@-find . -name '*.o' -delete
+	@-find . -name '*.a' -delete
diff -Naur build/solvers/glucose421/mtl/Alg.h solvers/glucose421/mtl/Alg.h
--- build/solvers/glucose421/mtl/Alg.h	2023-05-09 15:19:52.000000000 +0200
+++ solvers/glucose421/mtl/Alg.h	2023-07-04 16:12:37.708327670 +0200
@@ -18,12 +18,12 @@
 OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 **************************************************************************************************/
 
-#ifndef Glucose_Alg_h
-#define Glucose_Alg_h
+#ifndef Glucose421_Alg_h
+#define Glucose421_Alg_h
 
-#include "mtl/Vec.h"
+#include "glucose421/mtl/Vec.h"
 
-namespace Glucose {
+namespace Glucose421 {
 
 //=================================================================================================
 // Useful functions on vector-like types:
diff -Naur build/solvers/glucose421/mtl/Alloc.h solvers/glucose421/mtl/Alloc.h
--- build/solvers/glucose421/mtl/Alloc.h	2023-05-09 15:19:52.000000000 +0200
+++ solvers/glucose421/mtl/Alloc.h	2023-07-04 16:12:37.708327670 +0200
@@ -18,13 +18,13 @@
 **************************************************************************************************/
 
 
-#ifndef Glucose_Alloc_h
-#define Glucose_Alloc_h
+#ifndef Glucose421_Alloc_h
+#define Glucose421_Alloc_h
 
-#include "mtl/XAlloc.h"
-#include "mtl/Vec.h"
+#include "glucose421/mtl/XAlloc.h"
+#include "glucose421/mtl/Vec.h"
 
-namespace Glucose {
+namespace Glucose421 {
 
 //=================================================================================================
 // Simple Region-based memory allocator:
diff -Naur build/solvers/glucose421/mtl/Clone.h solvers/glucose421/mtl/Clone.h
--- build/solvers/glucose421/mtl/Clone.h	2023-05-09 15:19:52.000000000 +0200
+++ solvers/glucose421/mtl/Clone.h	2023-07-04 16:12:37.708327670 +0200
@@ -1,8 +1,8 @@
-#ifndef Glucose_Clone_h
-#define Glucose_Clone_h
+#ifndef Glucose421_Clone_h
+#define Glucose421_Clone_h
 
 
-namespace Glucose {
+namespace Glucose421 {
 
     class Clone {
         public:
diff -Naur build/solvers/glucose421/mtl/Heap.h solvers/glucose421/mtl/Heap.h
--- build/solvers/glucose421/mtl/Heap.h	2023-05-09 15:19:52.000000000 +0200
+++ solvers/glucose421/mtl/Heap.h	2023-07-04 16:12:37.708327670 +0200
@@ -18,12 +18,12 @@
 OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 **************************************************************************************************/
 
-#ifndef Glucose_Heap_h
-#define Glucose_Heap_h
+#ifndef Glucose421_Heap_h
+#define Glucose421_Heap_h
 
-#include "mtl/Vec.h"
+#include "glucose421/mtl/Vec.h"
 
-namespace Glucose {
+namespace Glucose421 {
 
 //=================================================================================================
 // A heap implementation with support for decrease/increase key.
diff -Naur build/solvers/glucose421/mtl/Map.h solvers/glucose421/mtl/Map.h
--- build/solvers/glucose421/mtl/Map.h	2023-05-09 15:19:52.000000000 +0200
+++ solvers/glucose421/mtl/Map.h	2023-07-04 16:12:37.708327670 +0200
@@ -17,15 +17,15 @@
 OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 **************************************************************************************************/
 
-#ifndef Glucose_Map_h
-#define Glucose_Map_h
+#ifndef Glucose421_Map_h
+#define Glucose421_Map_h
 
-#include "mtl/IntTypes.h"
-#include "mtl/Vec.h"
+#include "glucose421/mtl/IntTypes.h"
+#include "glucose421/mtl/Vec.h"
 #include <string>
 #include <unordered_map>
 
-namespace Glucose {
+namespace Glucose421 {
 
 //=================================================================================================
 // Default hash/equals functions
diff -Naur build/solvers/glucose421/mtl/Queue.h solvers/glucose421/mtl/Queue.h
--- build/solvers/glucose421/mtl/Queue.h	2023-05-09 15:19:52.000000000 +0200
+++ solvers/glucose421/mtl/Queue.h	2023-07-04 16:12:37.708327670 +0200
@@ -18,12 +18,12 @@
 OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 **************************************************************************************************/
 
-#ifndef Glucose_Queue_h
-#define Glucose_Queue_h
+#ifndef Glucose421_Queue_h
+#define Glucose421_Queue_h
 
-#include "mtl/Vec.h"
+#include "glucose421/mtl/Vec.h"
 
-namespace Glucose {
+namespace Glucose421 {
 
 //=================================================================================================
 
diff -Naur build/solvers/glucose421/mtl/Sort.h solvers/glucose421/mtl/Sort.h
--- build/solvers/glucose421/mtl/Sort.h	2023-05-09 15:19:52.000000000 +0200
+++ solvers/glucose421/mtl/Sort.h	2023-07-04 16:12:37.708327670 +0200
@@ -18,16 +18,16 @@
 OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 **************************************************************************************************/
 
-#ifndef Glucose_Sort_h
-#define Glucose_Sort_h
+#ifndef Glucose421_Sort_h
+#define Glucose421_Sort_h
 
-#include "mtl/Vec.h"
+#include "glucose421/mtl/Vec.h"
 
 //=================================================================================================
 // Some sorting algorithms for vec's
 
 
-namespace Glucose {
+namespace Glucose421 {
 
 template<class T>
 struct LessThan_default {
diff -Naur build/solvers/glucose421/mtl/Vec.h solvers/glucose421/mtl/Vec.h
--- build/solvers/glucose421/mtl/Vec.h	2023-05-09 15:19:52.000000000 +0200
+++ solvers/glucose421/mtl/Vec.h	2023-07-04 16:12:37.708327670 +0200
@@ -18,17 +18,17 @@
 OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 **************************************************************************************************/
 
-#ifndef Glucose_Vec_h
-#define Glucose_Vec_h
+#ifndef Glucose421_Vec_h
+#define Glucose421_Vec_h
 
 #include <assert.h>
 #include <new>
 
-#include "mtl/IntTypes.h"
-#include "mtl/XAlloc.h"
+#include "glucose421/mtl/IntTypes.h"
+#include "glucose421/mtl/XAlloc.h"
 #include<string.h>
 
-namespace Glucose {
+namespace Glucose421 {
 
 //=================================================================================================
 // Automatically resizable arrays
diff -Naur build/solvers/glucose421/mtl/VecThreads.h solvers/glucose421/mtl/VecThreads.h
--- build/solvers/glucose421/mtl/VecThreads.h	2023-05-09 15:19:52.000000000 +0200
+++ solvers/glucose421/mtl/VecThreads.h	2023-07-04 16:12:37.708327670 +0200
@@ -19,17 +19,17 @@
 OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 **************************************************************************************************/
 
-#ifndef Glucose_VecThreads_h
-#define Glucose_VecThreads_h
+#ifndef Glucose421_VecThreads_h
+#define Glucose421_VecThreads_h
 
 #include <assert.h>
 #include <new>
 
-#include "mtl/IntTypes.h"
-#include "mtl/XAlloc.h"
+#include "glucose421/mtl/IntTypes.h"
+#include "glucose421/mtl/XAlloc.h"
 #include<string.h>
 
-namespace Glucose {
+namespace Glucose421 {
 
 //=================================================================================================
 // Automatically resizable arrays
diff -Naur build/solvers/glucose421/mtl/XAlloc.h solvers/glucose421/mtl/XAlloc.h
--- build/solvers/glucose421/mtl/XAlloc.h	2023-05-09 15:19:52.000000000 +0200
+++ solvers/glucose421/mtl/XAlloc.h	2023-07-04 16:12:37.708327670 +0200
@@ -18,14 +18,14 @@
 **************************************************************************************************/
 
 
-#ifndef Glucose_XAlloc_h
-#define Glucose_XAlloc_h
+#ifndef Glucose421_XAlloc_h
+#define Glucose421_XAlloc_h
 
 #include <errno.h>
 #include <stdlib.h>
 #include <stdio.h>
 
-namespace Glucose {
+namespace Glucose421 {
 
 //=================================================================================================
 // Simple layer on top of malloc/realloc to catch out-of-memory situtaions and provide some typing:
diff -Naur build/solvers/glucose421/utils/Options.cc solvers/glucose421/utils/Options.cc
--- build/solvers/glucose421/utils/Options.cc	2023-05-09 15:19:52.000000000 +0200
+++ solvers/glucose421/utils/Options.cc	2023-07-04 16:12:37.708327670 +0200
@@ -17,13 +17,13 @@
 OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 **************************************************************************************************/
 
-#include "mtl/Sort.h"
-#include "utils/Options.h"
-#include "utils/ParseUtils.h"
+#include "glucose421/mtl/Sort.h"
+#include "glucose421/utils/Options.h"
+#include "glucose421/utils/ParseUtils.h"
 
-using namespace Glucose;
+using namespace Glucose421;
 
-void Glucose::parseOptions(int& argc, char** argv, bool strict)
+void Glucose421::parseOptions(int& argc, char** argv, bool strict)
 {
     int i, j;
     for (i = j = 1; i < argc; i++){
@@ -54,15 +54,15 @@
 }
 
 
-void Glucose::setUsageHelp      (const char* str){ Option::getUsageString() = str; }
-void Glucose::setHelpPrefixStr  (const char* str){ Option::getHelpPrefixString() = str; }
-void Glucose::printUsageAndExit (int argc, char** argv, bool verbose)
+void Glucose421::setUsageHelp      (const char* str){ Option::getUsageString() = str; }
+void Glucose421::setHelpPrefixStr  (const char* str){ Option::getHelpPrefixString() = str; }
+void Glucose421::printUsageAndExit (int argc, char** argv, bool verbose)
 {
     const char* usage = Option::getUsageString();
     if (usage != NULL)
         fprintf(stderr, usage, argv[0]);
 
-        sort(Option::getOptionList(), Option::OptionLt());
+    sort(Option::getOptionList(), Option::OptionLt());
 
     const char* prev_cat  = NULL;
     const char* prev_type = NULL;
diff -Naur build/solvers/glucose421/utils/Options.h solvers/glucose421/utils/Options.h
--- build/solvers/glucose421/utils/Options.h	2023-05-09 15:19:52.000000000 +0200
+++ solvers/glucose421/utils/Options.h	2023-07-04 16:12:37.708327670 +0200
@@ -17,19 +17,19 @@
 OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 **************************************************************************************************/
 
-#ifndef Glucose_Options_h
-#define Glucose_Options_h
+#ifndef Glucose421_Options_h
+#define Glucose421_Options_h
 
 #include <stdlib.h>
 #include <stdio.h>
 #include <math.h>
 #include <string.h>
 
-#include "mtl/IntTypes.h"
-#include "mtl/Vec.h"
-#include "utils/ParseUtils.h"
+#include "glucose421/mtl/IntTypes.h"
+#include "glucose421/mtl/Vec.h"
+#include "glucose421/utils/ParseUtils.h"
 
-namespace Glucose {
+namespace Glucose421 {
 
 //==================================================================================================
 // Top-level option parse/help functions:
diff -Naur build/solvers/glucose421/utils/ParseUtils.h solvers/glucose421/utils/ParseUtils.h
--- build/solvers/glucose421/utils/ParseUtils.h	2023-05-09 15:19:52.000000000 +0200
+++ solvers/glucose421/utils/ParseUtils.h	2023-07-04 16:12:37.708327670 +0200
@@ -18,8 +18,8 @@
 OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 **************************************************************************************************/
 
-#ifndef Glucose_ParseUtils_h
-#define Glucose_ParseUtils_h
+#ifndef Glucose421_ParseUtils_h
+#define Glucose421_ParseUtils_h
 
 #include <stdlib.h>
 #include <stdio.h>
@@ -27,7 +27,7 @@
 
 #include <zlib.h>
 
-namespace Glucose {
+namespace Glucose421 {
 
 //-------------------------------------------------------------------------------------------------
 // A simple buffered character stream class:
@@ -91,20 +91,18 @@
     if      (*in == '-') neg = true, ++in;
     else if (*in == '+') ++in;
     if (*in < '1' || *in > '9') printf("PARSE ERROR! Unexpected char: %c\n", *in), exit(3);
-	accu = (double)(*in - '0');
-	++in;
-	if (*in != '.') printf("PARSE ERROR! Unexpected char: %c\n", *in),exit(3);
-	++in; // skip dot
-	currentExponent = 0.1;
+    accu = (double)(*in - '0');
+    ++in;
+    if (*in != '.') printf("PARSE ERROR! Unexpected char: %c\n", *in), exit(3);
+    ++in; // skip dot
+    currentExponent = 0.1;
     while (*in >= '0' && *in <= '9')
-        accu = accu + currentExponent * ((double)(*in - '0')),
-		currentExponent /= 10,
-        ++in;
-	if (*in != 'e') printf("PARSE ERROR! Unexpected char: %c\n", *in),exit(3);
-	++in; // skip dot
-	exponent = parseInt(in); // read exponent
-	accu *= pow(10,exponent);
-	return neg ? -accu:accu;
+        accu = accu + currentExponent * ((double)(*in - '0')), currentExponent /= 10, ++in;
+    if (*in != 'e') printf("PARSE ERROR! Unexpected char: %c\n", *in), exit(3);
+    ++in; // skip dot
+    exponent = parseInt(in); // read exponent
+    accu *= pow(10,exponent);
+    return neg ? -accu:accu;
 }
 
 
diff -Naur build/solvers/glucose421/utils/System.cc solvers/glucose421/utils/System.cc
--- build/solvers/glucose421/utils/System.cc	2023-05-09 15:19:52.000000000 +0200
+++ solvers/glucose421/utils/System.cc	2023-07-04 16:12:37.708327670 +0200
@@ -18,14 +18,14 @@
 OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 **************************************************************************************************/
 
-#include "utils/System.h"
+#include "glucose421/utils/System.h"
 
 #if defined(__linux__)
 
 #include <stdio.h>
 #include <stdlib.h>
 
-using namespace Glucose;
+using namespace Glucose421;
 
 // TODO: split the memory reading functions into two: one for reading high-watermark of RSS, and
 // one for reading the current virtual memory size.
@@ -67,14 +67,14 @@
     return peak_kb;
 }
 
-double Glucose::memUsed() { return (double)memReadStat(0) * (double)getpagesize() / (1024*1024); }
-double Glucose::memUsedPeak() { 
+double Glucose421::memUsed() { return (double)memReadStat(0) * (double)getpagesize() / (1024*1024); }
+double Glucose421::memUsedPeak() { 
     double peak = memReadPeak() / 1024;
     return peak == 0 ? memUsed() : peak; }
 
 #elif defined(__FreeBSD__)
 
-double Glucose::memUsed(void) {
+double Glucose421::memUsed(void) {
     struct rusage ru;
     getrusage(RUSAGE_SELF, &ru);
     return (double)ru.ru_maxrss / 1024; }
@@ -84,12 +84,12 @@
 #elif defined(__APPLE__)
 #include <malloc/malloc.h>
 
-double Glucose::memUsed(void) {
+double Glucose421::memUsed(void) {
     malloc_statistics_t t;
     malloc_zone_statistics(NULL, &t);
     return (double)t.max_size_in_use / (1024*1024); }
 
 #else
-double Glucose::memUsed() { 
+double Glucose421::memUsed() { 
     return 0; }
 #endif
diff -Naur build/solvers/glucose421/utils/System.h solvers/glucose421/utils/System.h
--- build/solvers/glucose421/utils/System.h	2023-05-09 15:19:52.000000000 +0200
+++ solvers/glucose421/utils/System.h	2023-07-04 16:12:37.708327670 +0200
@@ -18,18 +18,18 @@
 OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 **************************************************************************************************/
 
-#ifndef Glucose_System_h
-#define Glucose_System_h
+#ifndef Glucose421_System_h
+#define Glucose421_System_h
 
 #if defined(__linux__)
 #include <fpu_control.h>
 #endif
 
-#include "mtl/IntTypes.h"
+#include "glucose421/mtl/IntTypes.h"
 
 //-------------------------------------------------------------------------------------------------
 
-namespace Glucose {
+namespace Glucose421 {
 
 static inline double cpuTime(void); // CPU-time in seconds.
 static inline double realTime(void);
@@ -44,14 +44,14 @@
 #if defined(_MSC_VER) || defined(__MINGW32__)
 #include <time.h>
 
-static inline double Glucose::cpuTime(void) { return (double)clock() / CLOCKS_PER_SEC; }
+static inline double Glucose421::cpuTime(void) { return (double)clock() / CLOCKS_PER_SEC; }
 
 #else
 #include <sys/time.h>
 #include <sys/resource.h>
 #include <unistd.h>
 
-static inline double Glucose::cpuTime(void) {
+static inline double Glucose421::cpuTime(void) {
     struct rusage ru;
     getrusage(RUSAGE_SELF, &ru);
     return (double)ru.ru_utime.tv_sec + (double)ru.ru_utime.tv_usec / 1000000; }
@@ -59,7 +59,7 @@
 #endif
 
 // Laurent: I know that this will not compile directly under Windows... sorry for that
-static inline double Glucose::realTime() {
+static inline double Glucose421::realTime() {
     struct timeval tv;
     gettimeofday(&tv, NULL);
     return (double)tv.tv_sec + (double) tv.tv_usec / 1000000; }
